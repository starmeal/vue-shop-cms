<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>123321</title>
</head>

<body>
    <script>
        // 插入排序
        function insert(ary) {
            // 1准备新数组用来存储开始先放一个进去
            let handle = []
            handle.push(ary[0])
            // 从第二项开始以此比较
            for (let i = 1; i < ary.length; i++) {
                let A = ary[i]
                //跟第一个比较从后向前比较
                for (let j = handle.length - 1; j >= 0; j--) {
                    // 每一次要比较存放的
                    let B = handle[j]
                    // 如果当前的新牌A必要比较的牌大,把A放到B的后面
                    if (A > B) {
                        handle.splice(j + 1, 0, A)
                        break
                    }
                    if (j === 0) {
                        handle.unshift(A)
                    }
                }
            }
            return handle
        }
        let ary = [12, 8, 24, 16, 1];
        // console.log(insert(ary));
        Function.prototype.myCall = function (context, ...arg) {
            const fn = Symbol('临时属性')
            context[fn] = this
            context[fn](...arg)
            delete context[fn]
        }
        function a(a, b, c) {
            console.log(this.name);
            console.log(a, b, c)
        }
        const b = {
            name: "segmentFault"
        }
            // a.myCall(b, 1, 2, 3)
            // 查找字符串
            ; (function () {
                // 循环原始字符串每一项，让每一项从当前位置后截取 t.length个字符串跟t进行比较如果不一样继续循环，如果一样返回当前索引循环结束
                function myIndexOf(t) {
                    let lenT = t.length, lenS = this.length, res = -1
                    // 循环查找减去需要查找的位数才能找到
                    for (let i = 0; i <= lenS - lenT; i++) {
                        let char = this[i]
                        if (this.substr(i, lenT) === t) {
                            res = i
                            break
                        }
                    }
                    return res
                }
                String.prototype.myIndexOf = myIndexOf
            })();
        let S = 'helloWord',
            t = "d"
        // console.log(S.myIndexOf(t))
        Function.prototype.newCall = function (obj) {
            var obj = obj || window
            obj.p = this
            var newArguments = []
            for (var i = 1; i < arguments.length; i++) {
                newArguments.push('arguments[' + i + ']')
            }
            var result = eval('obj.p(' + newArguments + ')')
            delete obj.p
            return result
        }
        a.newCall(b, 1, 2, 3, 4)
        // function ccc (a, b, c) {
        //   return a + b + c
        // }
        // function curry (fn, ...currags) {
        //    return currags.length < fn.length ? (...innerarg) => curry(fn, ...currags, ...innerarg) : fn(...currags)
        // }
        // let add = curry(ccc);
        // console.log(add(1)(2)(3))
        // console.log(add(1)(2,3))
        // console.log(add(1,2)(3))
        // console.log(add(1,2,3))
        function Parent(age, name) {
            this.age = age
            this.name = name
            this.sayAge = function () {
                console.log('this.age :', this.age)
            }
        }
        Parent.prototype.sayName = function () {
            console.log('this.name :', this.name)
        }
        function New(Fn) {
            let obj = {}
            let arg = Array.prototype.slice.call(arguments, 1)
            obj.__proto__ = Fn.prototype
            obj.__proto__.constructor = Fn
            Fn.apply(obj, arg)
            return obj
        }
        let newSon = New(Parent, 18, 'lining')
        console.log('newSon :', newSon)
    </script>
</body>

</html>